#summary Error messages explained
#labels Featured

<wiki:toc max_depth="2" />

=Introduction=
Did !EqualsVerifier give an error message that you didn't understand? I do my best, but unfortunately Java stacktraces leave little room for explanation. This page should help make sense of some of !EqualsVerifier's error messages.

==I can't find my error message in the list below==
This is not a complete list. I'll add to it as needed, so if you need help with an error message, please file [http://code.google.com/p/equalsverifier/issues/entry an issue] in the Issue tracker or let me know on the [http://groups.google.com/group/equalsverifier discussion group], and I'll add an explanation as soon as possible.

=Error messages=

==Abstract delegation==
<pre>
Abstract delegation: !MyClass's equals method delegates to an abstract method
Abstract delegation: !MyClass's hashCode method delegates to an abstract method
</pre>

This error can occur when the class under test, one of its fields, or its superclass, is abstract, and their `equals` or `hashCode` method calls an abstract method.

!EqualsVerifier creates instances of the class under test and its superclass and repeatedly calls their `equals` and `hashCode` methods. However, it can't create implementations of abstract methods. The "Abstract delegation" error therefore occurs when calling `equals` or `hashCode` would throw an `AbstractMethodError`.

If one of the fields has an abstract type, the error can be avoided by calling `withPrefabValues` for that type. For other cases, there is currently no solution. Try rewriting the class so that `equals` and `hashCode` can use fields, instead of the abstract method.

==!ClassCastException: java.lang.Object cannot be cast to ...==
There can be two causes for this error message. First, maybe you really did cast an `Object` to something it's not. Can't find the cast? Call !EqualsVerifier with the `.debug()` method to see a full stacktrace.

Second, it might be a generics problem. In this case, it will always be `java.lang.Object` that cannot be cast to some other class. Consider the following (partial) class:

{{{
final class StringReference {
	private final AtomicReference<String> stringRef;

	@Override
	public boolean equals(Object obj) {
		referToGenericParameter();
		
		if (!(obj instanceof StringReference)) {
			return false;
		}
		StringReference other = (StringReference)obj;
		return stringRef.equals(other.stringRef);
	}

	private void referToGenericParameter() {
		stringRef.get().length();
	}
}
}}}

In this case, !EqualsVerifier will say "java.lang.Object cannot be cast to java.lang.String". !EqualsVerifier can't see that the `AtomicReference`'s generic type parameter is `String` (due to [http://download.oracle.com/javase/tutorial/java/generics/erasure.html type erasure]). Instead, it will just put in an `Object`. Normally, this isn't a problem, but in this case, a direct reference is made to a `String` method in `referToGenericParameter`. `Object` doesn't have a `length()` method, so the object inside the `AtomicReference` is (implicitly) cast to `String`. Since !EqualsVerifier put in an `Object`, this fails.

How to fix this? It's easy. Just add a call to `withPrefabValues()`:

{{{
EqualsVerifier.forClass(StringReference.class)
        .withPrefabValues(AtomicReference.class, new AtomicReference<String>("string"), new AtomicReference<String>("another string"))
        .verify();
}}}

!EqualsVerifier will always look inside the pool of prefabricated values before building its own. So in this case, when it looks for instances of `AtomicReference`, it will find two `AtomicReference`s with `String`s already filled in. Problem solved!

==Mutability: equals depends on mutable field==
Your `equals` method references a field that is not final. This means that if the value of this field changes, the same object may not be equal to itself at two different points in time. This can be a problem if you use this object as a key in a map, or if you put it in a `HashSet` or other hash-based collection: the collection might not be able to find your object again.

There are three ways to solve this:
 * Make your field final. This is the preferred solution.
 * Add an `@Immutable` annotation to your class if you _know_ that the class is immutable, but the fields cannot be final for some reason.
 * Suppress `Warning.NONFINAL_FIELDS` if your class has to be mutable.

Note: Unfortunately, `EqualsVerifier` cannnot detect if your fields are truly immutable, which is what's actually needed here. It can only see if fields are final, or if the class has an `@Immutable` annotation. 

==!NoClassDefFoundError==
<pre>
java.lang.AssertionError: java.lang.NoClassDefFoundError: net/sf/cglib/asm/FieldVisitor
</pre>

If you get this error message, then you probably have a transitive dependency problem with cglib. `EqualsVerifier` requires version 2.2, but other libraries may depend on earlier versions. If their dependency happens to be resolved before `EqualsVerifier`'s, the wrong version of cglib will be loaded on your classpath.

To fix this, make sure you have cglib 2.2. If you use Maven, add the following lines to your pom:
{{{
<dependencyManagement>
	<dependencies>
		<dependency>
			<groupId>cglib</groupId>
			<artifactId>cglib-nodep</artifactId>
			<version>2.2</version>
		</dependency>
	</dependencies>
</dependencyManagement>
}}}

==Non-nullity: equals/hashCode/toString throws !NullPointerException==
This error occurs when the class under test can throw a `NullPointerException` when one of its fields is null and `equals`/`hashCode`/`toString` is called. For example, `equals` could contain this line:
{{{
return someField.equals(other.someField);
}}}
It will throw a `NullPointerException` if `someField` is null. This can be avoided in two ways.

 # You can add a null check, like so:
 {{{
 return someField == null ? other.someField == null : someField.equals(other.someField);
 }}}
 # If you're certain the field can never be null (for instance, because the class's constructor explicitly checks for it), you can suppress `Warning.NULL_FIELDS` in your call to !EqualsVerifier.

==Significant fields: equals relies on x, but hashCode does not.==
The cause for this message is usually the obvious one.

If it's not, then it might be caused by a cached hashCode field, similar to the one in `java.lang.String`. For example, given the following (abridged) class:
{{{
class CachedHashCode {
	private final int x;
	private final int y;
	private int cachedHashCode = 0;

	public int hashCode() {
		if (cachedHashCode == 0) {
			cachedHashCode += 31 * x;
			cachedHashCode += 31 * y;
		}
		return cachedHashCode;
	}
}
}}}
`EqualsVerifier` thinks `cachedHashCode` is a regular field like all the others, and assigns it a value other than 0. The first thing the `hashCode` method does is compare it to 0. This yields false, so the method always returns `EqualsVerifier`'s (incorrect) value. `EqualsVerifier` doesn't know about this, so when it tries changing `x`, it notices a difference in the result of `equals`, but not in the result of `hashCode` (since the latter is never properly initialized). And this is why `EqualsVerifier` thinks the problem is caused by `x`.

Unfortunately, this kind of hashCode caching is really hard for `EqualsVerifier` to detect. Furthermore, if you actually do this, you either _really_ know what you're doing and then you probably don't need `EqualsVerifier` anyway (this applies to `String`), or you run the risk of doing it wrong (as in the example above, which isn't thread-safe) and shouldn't be using this trick in the first place. It's basically an optimization that will, in most cases anyway, be premature. The chances of `EqualsVerifier` supporting cached hashCodes in the future are therefore quite slim.

==Subclass: object is not equal to an instance of a trivial subclass with equal fields==
<pre>
Subclass: object is not equal to an instance of a trivial subclass with equal fields: ...
Consider making the class final.
</pre>

This error occurs when a class is non-final, and an instance of this class is not equal to an instance of a (dynamically generated) subclass of this class, even though their fields are all equal. It is easy to break the equals contract when inheritance is involved, even accidentally, and !EqualsVerifier will always err on the side of caution.

There are several ways to fix this problem:
 * Make the class final. This way, all inheritance headaches will be avoided. However, this is not always possible.
 * In frameworks like Java EE and Hibernate, it's often not allowed to make certain classes final, even if you don't intend to subclass them. In these cases, it's probably a safe bet that the framework will create dynamic proxy subclasses for you class. This error will most likely only pop up if you use `getClass()` in your equals method, like so:
 {{{
    public boolean equals(Object other) {
        if (other == null || !getClass().equals(other.getClass())) {
            return false;
        }
        // ...
    }
 }}}
 The solution, then, is to use an `instanceof` test instead:
 {{{
    public boolean equals(Object other) {
        if (!(other instanceof MyClass)) {
            return false;
        }
        // ...
    }
 }}}
 This way, a dynamic proxy subclass generated by the framework can still be equal to an object that you instantiate directly. Note that it is probably a good idea to make the `equals` and `hashCode` methods final as well. That way, nobody can accidentally (or purposely) break the contract by making a subclass and overriding `equals` and `hashCode`.
 * If you do intend your class to be overridden, but subclasses won't add state that needs to be included in the `equals`/`hashCode` contract, the above advice applies as well. Again, make you `equals` and `hashCode` methods final, to signal that no such state is to be added in subclasses.
 * If you intend your class to be overridden, and you also want subclasses to add state that needs to be included in the contract, things get complicated. In Item 8 of _Effective Java_, Josh Bloch argues that it is impossible to achieve this without breaking the contract. Nevertheless, it turns out to be possible. [http://www.artima.com/lejava/articles/equality.html This article] by Martin Odersky, Bill Venners and Lex Spoon explains how to achieve this. If you decide to go down this path, you will need to supply !EqualsVerifier with an example of a subclass with added state, like this:
 {{{
    EqualsVerifier.forClass(MyClass.class)
        .withRedefinedSubclass(SomeSubclass.class)
        .verify();
 }}}
#summary Error messages explained
#labels Featured

<wiki:toc max_depth="2" />

=Introduction=
Did !EqualsVerifier give an error message that you didn't understand? I do my best, but unfortunately Java stacktraces leave little room for explanation. This page should help make sense of some of !EqualsVerifier's error messages.

==I can't find my error message in the list below==
This is not a complete list. I'll add to it as needed, so if you need help with an error message, please file [http://code.google.com/p/equalsverifier/issues/entry an issue] in the Issue tracker or let me know on the [http://groups.google.com/group/equalsverifier discussion group], and I'll add an explanation as soon as possible.

==A note about static fields==
As part of the verification process, !EqualsVerifier will assign values to all fields of the class under test, including static fields. The only exception to this are static final fields. These values are unpredictable, and often even invalid under normal conditions. This means that you have to be extra careful in the following circumstances:
 * If you have non-final static fields, and these fields are relevant in other unit tests, you may experience unpredictable behaviour. Consider making the static field either final or non-static, or reset the field (using reflection if it's private) immediately after calling !EqualsVerifier.
 * If you use <tt>!EqualsVerifier.forExamples</tt>, don't re-use the instances of the class under test. Instead, use dedicated instances for the !EqualsVerifier test. Otherwise, you might use instances with invalid values, which might mess up your other tests.

=Error messages=

==Abstract delegation==
<pre>
Abstract delegation: !MyClass's equals method delegates to an abstract method
Abstract delegation: !MyClass's hashCode method delegates to an abstract method
</pre>

This error can occur when the class under test, one of its fields, or its superclass, is abstract, and their `equals` or `hashCode` method calls an abstract method.

!EqualsVerifier creates instances of the class under test and its superclass and repeatedly calls their `equals` and `hashCode` methods. However, it can't create implementations of abstract methods. The "Abstract delegation" error therefore occurs when calling `equals` or `hashCode` would throw an `AbstractMethodError`.

If one of the fields has an abstract type, the error can be avoided by calling `withPrefabValues` for that type. For other cases, there is currently no solution. Try rewriting the class so that `equals` and `hashCode` can use fields, instead of the abstract method.

==!ClassCastException: java.lang.Object cannot be cast to ...==
There can be two causes for this error message. First, maybe you really did cast an `Object` to something it's not. Can't find the cast? Call !EqualsVerifier with the `.debug()` method to see a full stacktrace.

Second, it might be a generics problem. In this case, it will always be `java.lang.Object` that cannot be cast to some other class. Consider the following (partial) class:

{{{
final class StringReference {
	private final AtomicReference<String> stringRef;

	@Override
	public boolean equals(Object obj) {
		referToGenericParameter();
		
		if (!(obj instanceof StringReference)) {
			return false;
		}
		StringReference other = (StringReference)obj;
		return stringRef.equals(other.stringRef);
	}

	private void referToGenericParameter() {
		stringRef.get().length();
	}
}
}}}

In this case, !EqualsVerifier will say "java.lang.Object cannot be cast to java.lang.String". !EqualsVerifier can't see that the `AtomicReference`'s generic type parameter is `String` (due to [http://download.oracle.com/javase/tutorial/java/generics/erasure.html type erasure]). Instead, it will just put in an `Object`. Normally, this isn't a problem, but in this case, a direct reference is made to a `String` method in `referToGenericParameter`. `Object` doesn't have a `length()` method, so the object inside the `AtomicReference` is (implicitly) cast to `String`. Since !EqualsVerifier put in an `Object`, this fails.

How to fix this? It's easy. Just add a call to `withPrefabValues()`:

{{{
EqualsVerifier.forClass(StringReference.class)
        .withPrefabValues(AtomicReference.class, new AtomicReference<String>("string"), new AtomicReference<String>("another string"))
        .verify();
}}}

!EqualsVerifier will always look inside the pool of prefabricated values before building its own. So in this case, when it looks for instances of `AtomicReference`, it will find two `AtomicReference`s with `String`s already filled in. Problem solved!

==Double: equals doesn't use Double.compare for field foo==
You should never use `==` to compare doubles or floats in an `equals` method. Always use `Double.compare` or [http://download.oracle.com/javase/6/docs/api/java/lang/Double.html#compareTo%28java.lang.Double%29 `Double.compareTo`] instead.

Josh Bloch explains this in his book Effective Java. The short summary is that this method will do the right thing when confronted with `NaN` and positive and negative infinities. For example, `Float.NaN` is not equal to itself, but it has to be for `equals`, or you would never be able to retrieve it from a `HashMap`.

==Float: equals doesn't use Float.compare for field foo==
See the answer for `Double` above.

==Mutability: equals depends on mutable field==
Your `equals` method references a field that is not final. This means that if the value of this field changes, the same object may not be equal to itself at two different points in time. This can be a problem if you use this object as a key in a map, or if you put it in a `HashSet` or other hash-based collection: the collection might not be able to find your object again.

There are three ways to solve this:
 * Make your field final. This is the preferred solution.
 * Add an `@Immutable` annotation to your class if you _know_ that the class is immutable, but the fields cannot be final for some reason.
 * Suppress `Warning.NONFINAL_FIELDS` if your class has to be mutable.

Note: Unfortunately, `EqualsVerifier` cannnot detect if your fields are truly immutable, which is what's actually needed here. It can only see if fields are final, or if the class has an `@Immutable` annotation. 

==!NoClassDefFoundError==
<pre>
java.lang.AssertionError: java.lang.NoClassDefFoundError: net/sf/cglib/asm/FieldVisitor
</pre>

If you get this error message, then you probably have a transitive dependency problem with cglib. `EqualsVerifier` requires version 2.2, but other libraries may depend on earlier versions. If their dependency happens to be resolved before `EqualsVerifier`'s, the wrong version of cglib will be loaded on your classpath.

To fix this, make sure you have cglib 2.2. If you use Maven, add the following lines to your pom:
{{{
<dependencyManagement>
	<dependencies>
		<dependency>
			<groupId>cglib</groupId>
			<artifactId>cglib-nodep</artifactId>
			<version>2.2</version>
		</dependency>
	</dependencies>
</dependencyManagement>
}}}

Also, make sure that you use cglib-nodep, instead of 'vanilla' cglib!

==Non-nullity: equals/hashCode/toString throws !NullPointerException==
This error occurs when the class under test can throw a `NullPointerException` when one of its fields is null and `equals`/`hashCode`/`toString` is called. For example, `equals` could contain this line:
{{{
return foo.equals(other.foo);
}}}
It will throw a `NullPointerException` if `foo` is null. This can be avoided in two ways.

 # You can add a null check, like so:
 {{{
 return foo == null ? other.foo == null : foo.equals(other.foo);
 }}}
 # If you're certain the field can never be null (for instance, because the class's constructor explicitly checks for it), you can suppress `Warning.NULL_FIELDS` in your call to !EqualsVerifier.

==Recursive datastructure==

<pre>
Recursive datastructure.
Add prefab values for one of the following types: com.example.Foo.
</pre>
  One of the fields in `Foo` is of type `Foo` itself.

<pre>
Recursive datastructure.
Add prefab values for one of the following types: com.example.Foo, com.example.Bar.
</pre>
  One of the fields in `Foo` is of type `Bar`, and one of the fields in `Bar` is of type `Foo`.

`EqualsVerifier` will recursively try to instantiate objects of every class it encounters, but cannot do so if there is a loop in the object graph. In this case it's necessary to add predefined instances of one of the classes involved in the loop. If `EqualsVerifier` mentions more than one class, it doesn't matter which one you choose, although if one of these classes is the class that you are testing, it is probably better to choose another.

Example:
 {{{
    EqualsVerifier.forClass(MyClass.class)
        .withPrefabValues(Foo.class, new Foo(1), new Foo(2))
        .verify();
 }}}

If `com.example.Foo` is a interface or an abstract class, it's fine to use instances from any implementation of `com.example.Foo`.

Note that static fields are ignored only if they are also final.


==Significant fields: equals relies on foo, but hashCode does not==
The cause for this message is usually the obvious one.

If it's not, then it might be caused by a cached hashCode field, similar to the one in `java.lang.String`. For example, given the following (abridged) class:
{{{
class CachedHashCode {
	private final int foo;
	private final int bar;
	private int cachedHashCode = 0;

	public int hashCode() {
		if (cachedHashCode == 0) {
			cachedHashCode += 31 * foo;
			cachedHashCode += 31 * bar;
		}
		return cachedHashCode;
	}
}
}}}
`EqualsVerifier` thinks `cachedHashCode` is a regular field like all the others, and assigns it a value other than 0. The first thing the `hashCode` method does is compare it to 0. This yields false, so the method always returns `EqualsVerifier`'s (incorrect) value. `EqualsVerifier` doesn't know about this, so when it tries changing `foo`, it notices a difference in the result of `equals`, but not in the result of `hashCode` (since the latter is never properly initialized). And this is why `EqualsVerifier` thinks the problem is caused by `foo`.

Unfortunately, this kind of hashCode caching is really hard for `EqualsVerifier` to detect. Furthermore, if you actually do this, you either _really_ know what you're doing and then you probably don't need `EqualsVerifier` anyway (this applies to `String`), or you run the risk of doing it wrong (as in the example above, which isn't thread-safe) and shouldn't be using this trick in the first place. It's basically an optimization that will, in most cases anyway, be premature. The chances of `EqualsVerifier` supporting cached hashCodes in the future are therefore quite slim.

==Subclass: equals is not final==
<pre>
Subclass: equals is not final.
Supply an instance of a redefined subclass using withRedefinedSubclass if equals cannot be final.
</pre>

There are three ways to solve this error, in order of decreasing preference:

 * Make the `equals` method (or even the whole class) final.
 * If you intend your `equals` method to be overridden, and you also want subclasses to add state that needs to be included in the contract, things get complicated. In Item 8 of _Effective Java_, Josh Bloch argues that it is impossible to achieve this without breaking the contract. Nevertheless, it turns out to be possible. [http://www.artima.com/lejava/articles/equality.html This article] by Martin Odersky, Bill Venners and Lex Spoon explains how to achieve this. If you decide to go down this path, you will need to supply !EqualsVerifier with an example of a subclass with added state, like this:
 {{{
    EqualsVerifier.forClass(MyClass.class)
        .withRedefinedSubclass(SomeSubclass.class)
        .verify();
 }}}
 * Use `.suppress(Warning.STRICT_INHERITANCE)` to suppress the error message.

==Subclass: object is not equal to an instance of a trivial subclass with equal fields==
<pre>
Subclass: object is not equal to an instance of a trivial subclass with equal fields: ...
Consider making the class final.
</pre>

This error occurs when a class is non-final, and an instance of this class is not equal to an instance of a (dynamically generated) subclass of this class, even though their fields are all equal. It is easy to break the equals contract when inheritance is involved, even accidentally, and !EqualsVerifier will always err on the side of caution.

There are several ways to fix this problem:
 * Make the class final. This way, all inheritance headaches will be avoided. However, this is not always possible.
 * In frameworks like Java EE and Hibernate, it's often not allowed to make certain classes final, even if you don't intend to subclass them. In these cases, it's probably a safe bet that the framework will create dynamic proxy subclasses for you class. This error will most likely only pop up if you use `getClass()` in your equals method, like so:
 {{{
    public boolean equals(Object other) {
        if (other == null || !getClass().equals(other.getClass())) {
            return false;
        }
        // ...
    }
 }}}
 The solution, then, is to use an `instanceof` test instead:
 {{{
    public boolean equals(Object other) {
        if (!(other instanceof MyClass)) {
            return false;
        }
        // ...
    }
 }}}
 This way, a dynamic proxy subclass generated by the framework can still be equal to an object that you instantiate directly. Note that it is probably a good idea to make the `equals` and `hashCode` methods final as well. That way, nobody can accidentally (or purposely) break the contract by making a subclass and overriding `equals` and `hashCode`.
 * If you do intend your class to be overridden, but subclasses won't add state that needs to be included in the `equals`/`hashCode` contract, the above advice applies as well. Again, make you `equals` and `hashCode` methods final, to signal that no such state is to be added in subclasses.
 * If you intend your class to be overridden, and you also want subclasses to add state that needs to be included in the contract, things get complicated. In Item 8 of _Effective Java_, Josh Bloch argues that it is impossible to achieve this without breaking the contract. Nevertheless, it turns out to be possible. [http://www.artima.com/lejava/articles/equality.html This article] by Martin Odersky, Bill Venners and Lex Spoon explains how to achieve this. If you decide to go down this path, you will need to supply !EqualsVerifier with an example of a subclass with added state, like this:
 {{{
    EqualsVerifier.forClass(MyClass.class)
        .withRedefinedSubclass(SomeSubclass.class)
        .verify();
 }}}

==Symmetry: ... does not equal superclass instance ...==
===Short explanation===
If you expected these to be equal, there is probably a bug in your `equals` method. If you expected them not to be equal, you can call `#withRedefinedSuperclass()` to silence the error.

===Long explanantion===
There are two kinds of subclasses:
 * the kind that adds state, and maybe also behaviour.
 * the kind that adds only behaviour.

`ColoredPoint`, as described by Martin Odersky et al. in [http://www.artima.com/lejava/articles/equality.html this article], is a clear example of a subclass that adds state. If you want to reflect this added state in its equals method, and still be able to make subclasses of `ColoredPoint` that can equal instances of `ColoredPoint` itself, you'll need to follow the advice laid out in the article and add a `canEqual` method.
Importantly, this situation implies that an instance of `ColoredPoint` can *never* be equal to an instance of Point, even if their coordinates are the same.

However, if you don't need to add state, you won't override equals and you can do away with the added complexity of a `canEqual` method.
More importantly, an instance of your class *should* be equal to an instance of its superclass if they have equal state. So the behaviour in this case is opposite to that of the subclass that adds state.
(Also, a couple of other tests need to be performed in this scenario, as you can see in the code.)

Unfortunately, `EqualsVerifier` cannot guess which scenario applies for any given class. So for one of these scenarios, `EqualsVerifier` needs to run with a "custom setting".

`EqualsVerifier` defaults to the latter case, i.e. the one where only behaviour is added. In my experience, this is the case that occurs more often. Moreover, it often happens without the programmer even realising it! For example, Hibernate creates a subclass of every entity class.
A subclass that adds state, needs more ceremony: you'll have to add a `canEqual` method. Not many people know about this "trick", so it makes sense that this scenario occurs less often "in the wild". Therefore, this is the scenario that needs a custom setting: `#withRedefinedSuperclass()`.
#summary Error messages explained
#labels Featured

<wiki:toc max_depth="2" />

=Introduction=
Did !EqualsVerifier give an error message that you didn't understand? I do my best, but unfortunately Java stacktraces leave little room for explanation. This page should help make sense of some of !EqualsVerifier's error messages.

==I can't find my error message in the list below==
This is not a complete list. I'll add to it as needed, so if you need help with an error message, please file [http://code.google.com/p/equalsverifier/issues/entry an issue] in the Issue tracker or let me know on the [http://groups.google.com/group/equalsverifier discussion group], and I'll add an explanation as soon as possible.

=Error messages=

==Abstract delegation==
<pre>
Abstract delegation: !MyClass's equals method delegates to an abstract method
Abstract delegation: !MyClass's hashCode method delegates to an abstract method
</pre>

This error can occur when the class under test, one of its fields, or its superclass, is abstract, and their `equals` or `hashCode` method calls an abstract method.

!EqualsVerifier creates instances of the class under test and its superclass and repeatedly calls their `equals` and `hashCode` methods. However, it can't create implementations of abstract methods. The "Abstract delegation" error therefore occurs when calling `equals` or `hashCode` would throw an `AbstractMethodError`.

If one of the fields has an abstract type, the error can be avoided by calling `withPrefabValues` for that type. For other cases, there is currently no solution. Try rewriting the class so that `equals` and `hashCode` can use fields, instead of the abstract method.

==!ClassCastException: java.lang.Object cannot be cast to ...==
There can be two causes for this error message. First, maybe you really did cast an `Object` to something it's not. Can't find the cast? Call !EqualsVerifier with the `.debug()` method to see a full stacktrace.

Second, it might be a generics problem. In this case, it will always be `java.lang.Object` that cannot be cast to some other class. Consider the following (partial) class:

{{{
final class StringReference {
	private final AtomicReference<String> stringRef;

	@Override
	public boolean equals(Object obj) {
		referToGenericParameter();
		
		if (!(obj instanceof StringReference)) {
			return false;
		}
		StringReference other = (StringReference)obj;
		return stringRef.equals(other.stringRef);
	}

	private void referToGenericParameter() {
		stringRef.get().length();
	}
}
}}}

In this case, !EqualsVerifier will say "java.lang.Object cannot be cast to java.lang.String". !EqualsVerifier can't see that the `AtomicReference`'s generic type parameter is `String` (due to [http://download.oracle.com/javase/tutorial/java/generics/erasure.html type erasure]). Instead, it will just put in an `Object`. Normally, this isn't a problem, but in this case, a direct reference is made to a `String` method in `referToGenericParameter`. `Object` doesn't have a `length()` method, so the object inside the `AtomicReference` is (implicitly) cast to `String`. Since !EqualsVerifier put in an `Object`, this fails.

How to fix this? It's easy. Just add a call to `withPrefabValues()`:

{{{
EqualsVerifier.forClass(StringReference.class)
        .withPrefabValues(AtomicReference.class, new AtomicReference<String>("string"), new AtomicReference<String>("another string"))
        .verify();
}}}

!EqualsVerifier will always look inside the pool of prefabricated values before building its own. So in this case, when it looks for instances of `AtomicReference`, it will find two `AtomicReference`s with `String`s already filled in. Problem solved!

==Non-nullity: equals/hashCode/toString throws !NullPointerException==
This error occurs when the class under test can throw a `NullPointerException` when one of its fields is null and `equals`/`hashCode`/`toString` is called. For example, `equals` could contain this line:
{{{
return someField.equals(other.someField);
}}}
It will throw a `NullPointerException` if `someField` is null. This can be avoided in two ways.

 # You can add a null check, like so:
 {{{
 return someField == null ? other.someField == null : someField.equals(other.someField);
 }}}
 # If you're certain the field can never be null (for instance, because the class's constructor explicitly checks for it), you can suppress `Warning.NULL_FIELDS` in your call to !EqualsVerifier.

==Subclass: object is not equal to an instance of a trivial subclass with equal fields==
<pre>
Subclass: object is not equal to an instance of a trivial subclass with equal fields: ...
Consider making the class final.
</pre>

This error occurs when a class is non-final, and an instance of this class is not equal to an instance of a (dynamically generated) subclass of this class, even though their fields are all equal. It is easy to break the equals contract when inheritance is involved, even accidentally, and !EqualsVerifier will always err on the side of caution.

There are several ways to fix this problem:
 * Make the class final. This way, all inheritance headaches will be avoided. However, this is not always possible.
 * In frameworks like Java EE and Hibernate, it's often not allowed to make certain classes final, even if you don't intend to subclass them. In these cases, it's probably a safe bet that the framework will create dynamic proxy subclasses for you class. This error will most likely only pop up if you use `getClass()` in your equals method, like so:
 {{{
    public boolean equals(Object other) {
        if (other == null || !getClass().equals(other.getClass())) {
            return false;
        }
        // ...
    }
 }}}
 The solution, then, is to use an `instanceof` test instead:
 {{{
    public boolean equals(Object other) {
        if (!(other instanceof MyClass)) {
            return false;
        }
        // ...
    }
 }}}
 This way, a dynamic proxy subclass generated by the framework can still be equal to an object that you instantiate directly. Note that it is probably a good idea to make the `equals` and `hashCode` methods final as well. That way, nobody can accidentally (or purposely) break the contract by making a subclass and overriding `equals` and `hashCode`.
 * If you do intend your class to be overridden, but subclasses won't add state that needs to be included in the `equals`/`hashCode` contract, the above advice applies as well. Again, make you `equals` and `hashCode` methods final, to signal that no such state is to be added in subclasses.
 * If you intend your class to be overridden, and you also want subclasses to add state that needs to be included in the contract, things get complicated. In Item 8 of _Effective Java_, Josh Bloch argues that it is impossible to achieve this without breaking the contract. Nevertheless, it turns out to be possible. [http://www.artima.com/lejava/articles/equality.html This article] by Martin Odersky, Bill Venners and Lex Spoon explains how to achieve this. If you decide to go down this path, you will need to supply !EqualsVerifier with an example of a subclass with added state, like this:
 {{{
    EqualsVerifier.forClass(MyClass.class)
        .withRedefinedSubclass(SomeSubclass.class)
        .verify();
 }}}
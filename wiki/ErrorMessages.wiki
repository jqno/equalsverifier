#summary Error messages explained
#labels Featured

<wiki:toc max_depth="2" />

=Introduction=
Did !EqualsVerifier give an error message that you didn't understand? I do my best, but unfortunately Java stacktraces leave little room for explanation. This page should help make sense of some of !EqualsVerifier's error messages.

==I can't find my error message in the list below==
This is not a complete list. I'll add to it as needed, so if you need help with an error message, please file [http://code.google.com/p/equalsverifier/issues/entry an issue] in the Issue tracker or let me know on the [http://groups.google.com/group/equalsverifier discussion group], and I'll add an explanation as soon as possible.

=Error messages=

==Abstract delegation==
<pre>
Abstract delegation: !MyClass's equals method delegates to an abstract method
Abstract delegation: !MyClass's hashCode method delegates to an abstract method
</pre>

This error can occur when the class under test, one of its fields, or its superclass, is abstract, and their `equals` or `hashCode` method calls an abstract method.

!EqualsVerifier creates instances of the class under test and its superclass and repeatedly calls their `equals` and `hashCode` methods. However, it can't create implementations of abstract methods. The "Abstract delegation" error therefore occurs when calling `equals` or `hashCode` would throw an `AbstractMethodError`.

If one of the fields has an abstract type, the error can be avoided by calling `withPrefabValues` for that type. For other cases, there is currently no solution. Try rewriting the class so that `equals` and `hashCode` can use fields, instead of the abstract method.

==!ClassCastException: java.lang.Object cannot be cast to ...==
There can be two causes for this error message. First, maybe you really did cast an `Object` to something it's not. Can't find the cast? Call !EqualsVerifier with the `.debug()` method to see a full stacktrace.

Second, it might be a generics problem. In this case, it will always be `java.lang.Object` that cannot be cast to some other class. Consider the following (partial) class:

{{{
final class StringReference {
	private final AtomicReference<String> stringRef;

	@Override
	public boolean equals(Object obj) {
		referToGenericParameter();
		
		if (!(obj instanceof StringReference)) {
			return false;
		}
		StringReference other = (StringReference)obj;
		return stringRef.equals(other.stringRef);
	}

	private void referToGenericParameter() {
		stringRef.get().length();
	}
}
}}}

In this case, !EqualsVerifier will say "java.lang.Object cannot be cast to java.lang.String". !EqualsVerifier can't see that the `AtomicReference`'s generic type parameter is `String` (due to [http://download.oracle.com/javase/tutorial/java/generics/erasure.html type erasure]). Instead, it will just put in an `Object`. Normally, this isn't a problem, but in this case, a direct reference is made to a `String` method in `referToGenericParameter`. `Object` doesn't have a `length()` method, so the object inside the `AtomicReference` is (implicitly) cast to `String`. Since !EqualsVerifier put in an `Object`, this fails.

How to fix this? It's easy. Just add a call to `withPrefabValues()`:

{{{
EqualsVerifier.forClass(StringReference.class)
        .withPrefabValues(AtomicReference.class, new AtomicReference<String>("string"), new AtomicReference<String>("another string"))
        .verify();
}}}

!EqualsVerifier will always look inside the pool of prefabricated values before building its own. So in this case, when it looks for instances of `AtomicReference`, it will find two `AtomicReference`s with `String`s already filled in. Problem solved!

==Non-nullity: equals/hashCode/toString throws !NullPointerException==
This error occurs when the class under test can throw a `NullPointerException` when one of its fields is null and `equals`/`hashCode`/`toString` is called. For example, `equals` could contain this line:
{{{
return someField.equals(other.someField);
}}}
It will throw a `NullPointerException` if `someField` is null. This can be avoided in two ways.

 # You can add a null check, like so:
 {{{
 return someField == null ? other.someField == null : someField.equals(other.someField);
 }}}
 # If you're certain the field can never be null (for instance, because the class's constructor explicitly checks for it), you can suppress `Warning.NULL_FIELDS` in your call to !EqualsVerifier.
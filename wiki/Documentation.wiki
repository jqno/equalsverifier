#summary Documentation for EqualsVerifier
#labels Featured

`EqualsVerifier` can be used in Java unit tests to verify whether the contract for the `equals` and `hashCode` methods in a class is met. The contracts are described in the Javadoc comments for the `java.lang.Object` class.


By default, `EqualsVerifier` is as strict as possible. However, several methods exist to relax the strictness. 


Use, within unit test method, as follows:
  * Create an instance of `EqualsVerifier`. Either call `#forExamples(Object, Object, Object...)` to supply at least two instances of the class under test that are not equal to one another, or call `#forClass(Class)` to supply a reference to the class itself to
let the `EqualsVerifier` instantiate objects.
  * If the class under test is designed for inheritance, and the `equals` and `hashCode` methods can be overridden, an instance of the class is not permitted to be equal to an instance of a subclass, even though all the relevant fields are equal. Call `#withRedefinedSubclass(Class)` to supply a reference to such a subclass, or call `#with(Feature...)` with `Feature#WEAK_INHERITANCE_CHECK` to disable the check.
  * Call `#with(Feature...)` to modify the behaviour of `EqualsVerifier`.
  * Call `#verify()` to perform the actual verifications.


Example use:

{{{
@Test
public void equalsContract() {
    EqualsVerifier.forClass(My.class).verify();
}
}}}

Or, with some features enabled:

{{{
@Test
public void equalsContract() {
    EqualsVerifier.forClass(My.class)
            .with(Feature.ALLOW_MUTABLE_FIELDS, Feature.FIELDS_ARE_NEVER_NULL)
            .verify();
}
}}}


The following properties are verified:
  * Preconditions for `EqualsVerifier` itself.
  * Reflexivity and symmetry of the `equals` method.
  * Symmetry and transitivity of the `equals` method within an inheritance hierarchy, when applicable.
  * Consistency (by repeatedly calling `equals`).
  * "Non-nullity".
  * That `equals`, `hashCode` and `toString` not be able to throw `NullPointerException`. (Optional)
  * The `hashCode` contract.
  * That `equals` and `hashCode` be defined in terms of the same fields.
  * Immutability of the fields in terms of which `equals` and `hashCode` are defined. (Optional)
  * The finality of the fields in terms of which `equals` and `hashCode` are defined. (Optional)
  * Finality of the class under test and of the `equals` method itself, when applicable.


The last point warrants an explanation. While a class can define a perfect `equals` method, a subclass can still break this contract, even for its superclass. Therefore, a class should either be final, or the `equals` contract should hold for its subclasses as well. This means that an instance of a class should be equal to an instance of a subclass for which all fields are equal.

Similarly, if `equals` is overridden, it can break the contract. So either should the `equals` method be final, thereby guaranteeing its adherence to the contracts for itself and all its subclasses, or instances of the class may never be equal to instances of the subclass. This should be tested by calling `#withRedefinedSubclass(Class)`, and by using the `EqualsVerifier` for these subclasses separately as well. For an example of an implementation of such redefined `equals` methods, see `RedefinablePoint` in the `EqualsVerifier`'s unit tests. See Chapter 28 of _Programming in Scala_ (full reference below) for an explanation of how and why this works.

By calling `#weakInheritanceCheck()`, the latter check can be disabled. A call `#withRedefinedSubclass(Class)` is then no longer necessary.


Dependencies:
  * [http://code.google.com/p/objenesis/ objenesis 1.1]
  * [http://cglib.sourceforge.net/ cglib-nodep 2.2]


The verifications are inspired by:
  * _Effective Java, Second Edition_ by Joshua Bloch, Addison-Wesley, 2008: Items 8 (_Obey the general contract when overriding `equals`_) and 9 (_Always override `hashCode` when you override `equals`_).
  * _Programming in Scala_ by Martin Odersky, Lex Spoon and Bill Venners, Artima Press, 2008: Chapter 28 (_Object equality_).
  * _JUnit Recipes_ by J.B. Rainsberger, Manning, 2005: Appendix B.2 (_Strangeness and transitivity_).
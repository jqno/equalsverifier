#summary Frequently Asked Questions.
#labels Featured

<wiki:toc max_depth="2" />

=Philosophy=
==Can !EqualsVerifier give false positives?==
Yes, it can. !EqualsVerifier will not search a class's entire state space. If you write an `equals` method as below, !EqualsVerifier will not notice that it's incorrect.
{{{
public boolean equals(Object obj) {
    if (!(obj instanceof MyClass)) {
        return false;
    }
    if (myInt == 100) {
        return false;
    }
    return myInt == ((MyClass)obj).myInt;
}
}}}
The example is a little far-fetched, but it illustrates the point that you have to write bad code _on purpose_ to make !EqualsVerifier think your `equals` method is correct when it is not.

==Can !EqualsVerifier give false negatives?==
Yes, it can. Just try to verify `String`: it will fail. `String` employs some tricks for better performance, that !EqualsVerifer can't verify. However, the good people who wrote `String` knew what they were doing, and have proven their implementation correct. If you prove your implementation correct, you don't need !EqualsVerifier.

==So what's the point of !EqualsVerifier then?==
!EqualsVerifier is a useful tool for anyone who wants to implement the `equals` and `hashCode` methods, without trying anything fancy. Implementing `equals` is hard, even for simple classes. Since most classes are simple, !EqualsVerifier can be a great help in making sure that your implementation fulfills the contract.

!EqualsVerifier catches common mistakes, such as forgetting to include a field in `hashCode` that is tested in `equals`. It also encourages robustness, for example by warning about non-final fields, and by watching out for inheritance issues.

If you run into a situation where !EqualsVerifier can't help you, you are probably in one (or more) of the following situations:
 # You're writing non-trivial, high-performance niche code at NASA.
 # You're a Java API developer.
 # You're writing malicious code on purpose.
 # You're writing code that's way too complicated, and you should probably refactor.

(And even in the first two cases, !EqualsVerifier can help creating an initial working implementation.)

=Error messages=
==Abstract delegation==
<pre>
Abstract delegation: !MyClass's equals method delegates to an abstract method
Abstract delegation: !MyClass's hashCode method delegates to an abstract method
</pre>

This error can occur when the class under test, one of its fields, or its superclass, is abstract, and their `equals` or `hashCode` method calls an abstract method.

!EqualsVerifier creates instances of the class under test and its superclass and repeatedly calls their `equals` and `hashCode` methods. However, it can't create implementations of abstract methods. The "Abstract delegation" error therefore occurs when calling `equals` or `hashCode` would throw an `AbstractMethodError`.

If one of the fields has an abstract type, the error can be avoided by calling `withPrefabValues` for that type. For other cases, there is currently no solution. Try rewriting the class so that `equals` and `hashCode` can use fields, instead of the abstract method.

==Non-nullity: equals/hashCode/toString throws !NullPointerException==
This error occurs when the class under test can throw a `NullPointerException` when one of its fields is null and `equals`/`hashCode`/`toString` is called. For example, `equals` could contain this line:
{{{
return someField.equals(other.someField);
}}}
It will throw a `NullPointerException` if `someField` is null. This can be avoided in two ways.

 # You can add a null check, like so:
 {{{
 return someField == null ? other.someField == null : someField.equals(other.someField);
 }}}
 # If you're certain the field can never be null (for instance, because the class's constructor explicitly checks for it), you can suppress `Warning.NULL_FIELDS` in your call to !EqualsVerifier.

=Build=
==Can I use !EqualsVerifier with Maven?==
Yes! Click [Maven here] for details.

==How do I build !EqualsVerifier?==
First, check out the code. You can open the project in Eclipse, or you can run ANT directly. Note that Java 6 is required to compile the project, although the ANT script will generate Java 5 compatible JAR files.

==Why can't Eclipse resolve the dependencies?==
!EqualsVerifier uses [http://ant.apache.org/ivy/ Apache Ivy] to resolve all dependencies. If you want !EqualsVerifier to compile in Eclipse, you need to install the [http://ant.apache.org/ivy/ivyde/ IvyDE] plugin, which will take care of the dependencies for you.

==I get generics errors while building==
<pre>
type parameters of <S>S cannot be determined; no unique maximal instance exists for 
type variable S with upper bounds T,java.lang.Object
</pre>

!EqualsVerifier makes heavy use of generics. Sun's Java compiler has a known bug regarding generics. Since I use Eclipse and OpenJDK, which do not exhibit this bug, it's possible I write code that triggers the bug, and the code might not compile. If this happens, please let me know in an issue and I'll fix it.